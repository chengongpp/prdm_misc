# 概念一览

Linux内存管理模块结构复杂，在多年来的迭代更新中，包括了愈加丰富的功能，为各式各样的系统环境（从没有MMU的微控制器到超级计算机）提供内存管理支持。没有MMU的内存管理被叫做`nommu`，这块着实需要完善的文档，也总有一天会有人写文档。尽管很多概念在有无MMU的情况下都是一致的，本文在此假定系统有MMU而且CPU能够将虚拟地址翻译到物理地址。

## 虚拟内存简介

系统的物理内存资源有限：哪怕是支持内存热拔插的系统，它能插上去的内存也是有硬件上限的。物理内存地址不一定连续，而有可能是一系列分散的地址范围。此外，不同的CPU架构、同架构的不同实现，都有可能采用不同的方式来定义内存地址范围。

于是，直接和物理内存打交道就变得非常棘手，为了避免这种情况，人们提出了一个概念，叫虚拟内存。

从应用程序的角度来看，虚拟内存提供了对物理内存细节的屏蔽抽象，应用只需要在物理内存上存放少数必要的信息（按需分页）；虚拟内存还提供了进程间数据共享和保护的机制。

有了虚拟内存，访问内存时就用且只用到虚地址。CPU遇到需要对内存做存取的指令时，会将指令中的虚拟地址转换成内存控制器看得懂的物理地址。

物理内存被分成页帧，简称页。页的大小取决于架构实现，有些架构容许你从几个指定的大小中选，而你可以在编译内核时，通过调整选项来选定合适的大小。

一个物理内存页能被映射到一个或多个虚拟内存页，映射规则由页表描述。页表按层次组合起来，记录了程序用的虚拟地址到物理地址的转换关系。

最底层的页表描述了程序用到的页的真实物理地址，而往上层的页表描述了隶属于底层页表的页的真实物理地址。CPU进行地址翻译时，首先根据寄存器找到顶层页表；虚拟地址的高位用来指定顶层页表中的页表项，这个页表项又用来访问下一层的页表，虚拟地址的下一位又用来指定这层页表中的页表项，以此类推。虚拟地址的地位制定了物理页当中实际的内存偏移。

## 大内存页

地址翻译要求访问内存数次，而访问内存的速度相较之下远低于CPU的速度。为了避免太多的CPU开销浪费在地址翻译上，CPU会维护一个记录自己翻译结果的缓存，叫做TLB（Translation Lookaside Buffer）。一般来说，TLB是稀缺资源，吃内存的程序在TLB未命中的时候，性能会受到相当大的影响。

许多当代CPU架构容许在高层的页表直接做内存映射。比如说x86上，二级或三级页表可以直接做2M甚至上1G的页映射。在Linux当中，这一类内存页被称为**大**内存页。大内存页显著缓解了TLB的压力，提高了TLB的命中率，为系统性能带来全面的提升。

